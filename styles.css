/// SentariX â€” one-way floor tracking + input-anchored perceived time.
///
/// - Discovers physical RTT floor
/// - Rejects digital delay entirely
/// - Perceived time runs on local ticks, not RTT
/// - Return RTT used ONLY for drift correction
///
/// This file contains zero public items.
/// lib.rs exposes a minimal safe API.
#[derive(Debug, Clone, Copy)]
pub struct SentariX {
    tick_us: u64,
    max_drift_us_per_sec: i64,

    // Local running time
    local_us: u64,

    // Anchor state
    anchored: bool,
    anchor_local_us: u64,
    anchor_floor_rtt_us: u64,

    // Warmup floor discovery
    sample_count: u32,
    warmup_min_rtt_us: u64,

    // Post-anchor floor estimate + drift
    floor_rtt_us: u64,
    applied_offset_us: i64,

    // Stores perceived time from previous tick
    previous_perceived_us: i64,

    // Public diagnostics
    pub last_rtt_us: u64,
    pub estimated_floor_one_way_us: i64,
    pub perceived_us: i64,
}

impl SentariX {
    /// Generic constructor (internal invariants enforced)
    #[inline(always)]
    pub const fn new(tick_us: u64, max_drift_us_per_sec: i64) -> Self {
        // Hard minimum tick to avoid degenerate configs
        let tick_us = if tick_us < 100 { 100 } else { tick_us };

        // Negative drift makes no sense; clamp to 0
        let max_drift_us_per_sec = if max_drift_us_per_sec < 0 {
            0
        } else {
            max_drift_us_per_sec
        };

        Self {
            tick_us,
            max_drift_us_per_sec,
            local_us: 0,

            anchored: false,
            anchor_local_us: 0,
            anchor_floor_rtt_us: 0,

            sample_count: 0,
            warmup_min_rtt_us: u64::MAX,

            floor_rtt_us: 0,
            applied_offset_us: 0,

            previous_perceived_us: 0,

            last_rtt_us: 0,
            estimated_floor_one_way_us: 0,
            perceived_us: 0,
        }
    }

    /// 128 Hz default configuration
    #[inline(always)]
    pub const fn new_128hz() -> Self {
        Self::new(7812, 19)
    }

    /// Reset to initial state, keeping configuration
    #[inline(always)]
    pub fn reset(&mut self) {
        *self = Self::new(self.tick_us, self.max_drift_us_per_sec);
    }

    /// Whether warmup/anchoring is complete and perceived time is valid
    #[inline(always)]
    pub const fn is_anchored(&self) -> bool {
        self.anchored
    }

    /// Feed a new RTT sample (microseconds)
    #[inline(always)]
    pub fn update(&mut self, rtt_us: u64) {
        // ---------------------------------------------------------
        // LOCAL TIME ALWAYS ADVANCES FIRST (IMMOVABLE TIMELINE)
        // ---------------------------------------------------------
        self.local_us = self.local_us.wrapping_add(self.tick_us);

        // ---------------------------------------------------------
        // PATCH: Handle "no RTT sample" (packet loss)
        //
        // rtt_us == 0 means: "no update from the network".
        // We do NOT modify floor tracking or offset logic.
        // Only dt moves forward at full rate.
        //
        // Last known RTT stays so diagnostics look stable.
        // ---------------------------------------------------------
        if rtt_us == 0 {
            let delta_local = self.local_us.wrapping_sub(self.anchor_local_us) as i64;
            self.perceived_us = delta_local - self.applied_offset_us;
            return;
        }

        let rtt_us = rtt_us.clamp(1, 2_000_000);
        self.last_rtt_us = rtt_us;

        // ---------------------------
        // Warmup phase: strict minimum RTT
        // ---------------------------
        if !self.anchored {
            if self.sample_count == 0 || rtt_us < self.warmup_min_rtt_us {
                self.warmup_min_rtt_us = rtt_us;
            }

            self.sample_count += 1;
            self.estimated_floor_one_way_us = (self.warmup_min_rtt_us / 2) as i64;
            self.perceived_us = 0;

            if self.sample_count >= 128 {
                self.anchored = true;
                self.anchor_local_us = self.local_us;
                self.floor_rtt_us = self.warmup_min_rtt_us;
                self.anchor_floor_rtt_us = self.floor_rtt_us;
                self.previous_perceived_us = 0;
            }
            return;
        }

        // ---------------------------
        // Post-anchor floor tracking
        // ---------------------------
        let mut max_step =
            (self.max_drift_us_per_sec * self.tick_us as i64) / 1_000_000;
        if max_step < 1 {
            max_step = 1;
        }

        if self.floor_rtt_us == 0 {
            self.floor_rtt_us = rtt_us;
        } else if rtt_us >= self.floor_rtt_us {
            let rise_limit = self.floor_rtt_us.saturating_add(max_step as u64);
            if rtt_us < rise_limit {
                self.floor_rtt_us = rtt_us;
            } else {
                self.floor_rtt_us = rise_limit;
            }
        } else {
            let drop = self.floor_rtt_us - rtt_us;
            let big_drop_threshold = self.floor_rtt_us / 4;

            if drop <= big_drop_threshold {
                self.floor_rtt_us = rtt_us;
            } else {
                let step_down = max_step as u64;
                let new_floor = self.floor_rtt_us.saturating_sub(step_down);
                if new_floor <= rtt_us {
                    self.floor_rtt_us = rtt_us;
                } else {
                    self.floor_rtt_us = new_floor;
                }
            }
        }

        self.estimated_floor_one_way_us = (self.floor_rtt_us / 2) as i64;

        // ---------------------------
        // Offset slewing
        // ---------------------------
        let desired_offset =
            (self.floor_rtt_us as i64 - self.anchor_floor_rtt_us as i64) / 2;

        let err = desired_offset - self.applied_offset_us;
        let step = err.clamp(-max_step, max_step);

        self.applied_offset_us =
            self.applied_offset_us.saturating_add(step);

        // ---------------------------
        // Perceived timeline
        // ---------------------------
        let delta_local = self.local_us.wrapping_sub(self.anchor_local_us) as i64;

        self.perceived_us = delta_local - self.applied_offset_us;
    }

    /// Returns the perceived time delta for this tick (in microseconds).
    #[inline(always)]
    pub fn get_perceived_timestep(&mut self) -> i64 {
        let dt = self.perceived_us - self.previous_perceived_us;
        self.previous_perceived_us = self.perceived_us;
        dt
    }

    #[inline(always)]
    pub const fn perceived_time_us(&self) -> i64 {
        self.perceived_us
    }

    #[inline(always)]
    pub const fn floor_one_way_us(&self) -> i64 {
        self.estimated_floor_one_way_us
    }
}
